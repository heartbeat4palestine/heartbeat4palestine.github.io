{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"heartbeat4palestine For more information contact ABDELHADI MAHBOUB. \ufeffChapitre 1 Repr\u00e9sentation des nombres sur ordinateur ENSAM-Mekn\u00e8s Universit\u00e9 Moulay Ismail - Mekn\u00e8s 28 septembre 2011 1 Introduction 1 Repr\u00e9sentation des nombres sur ordinateur 1 Arithm\u00e9tique flottante Maths-Info (ENSAM) CMN 2 septembre 2011 2 / 42 Introduction Analyse num\u00e9rique L\u2019analyse Num\u00e9rique est une sp\u00e9cialit\u00e9 r\u00e9cente des math\u00e9matiques, elle s\u2019est d\u00e9velopp\u00e9e avec l\u2019apparition des ordinateurs. Son objet essentiel est d\u2019\u00e9crire les programmes permettant d\u2019effectuer les op\u00e9rations n\u00e9cessaires pour r\u00e9soudre num\u00e9riquement un probl\u00e8me donn\u00e9. Les m\u00e9thodes ont un \"co\u00fbt\", li\u00e9 d\u2019une part au temps de calcul, ie au nombre d\u2019op\u00e9rations \u00e9l\u00e9mentaires (additions, soustractions, multiplications et divisions) \u00e0 faire, et d\u2019autre part \u00e0 l\u2019espace m\u00e9moire n\u00e9cessaire pour stocker les donn\u00e9es et les r\u00e9sultats. L\u2019ordinateur ne fait pas de calculs exacts (\u00e0 cause du mode de repr\u00e9sentation des nombres). Ceci constitue un inconv\u00e9nient car cela provoque des erreurs d\u2019arrondis et de troncature. Pour un grand nombre de probl\u00e8mes, le seul moyen de calculer la solution, si elle existe, est de l\u2019approcher num\u00e9riquement. Un algorithme c\u2019est une d\u00e9marche pour obtenir une solution (impliquant des simplifications, ajout/retrait d\u2019hypoth\u00e8ses sur le mod\u00e8le, etc) ET l\u2019implementation sur ordinateur de cette d\u00e9marche. Objectifs de l\u2019analyse num\u00e9rique : proposer et d\u00e9velopper des algorithmes (m\u00e9thodes d\u2019approximation) pour calculer une solution approch\u00e9e, contr\u00f4ler les diverses sources d\u2019erreurs, propres \u00e0 l\u2019approximation num\u00e9rique, \u00e9valuer la pertinence et la valeur de diff\u00e9rents algorithmes (estimer leurs performances) pouvant \u00eatre utilis\u00e9s pour r\u00e9soudre le m\u00eame probl\u00e8me afin de s\u00e9lectionner les meilleurs . Quelques probl\u00e8mes typiques Interpolation - Extrapolation. R\u00e9solution de syst\u00e8mes lin\u00e9aires. R\u00e9solution de syst\u00e8mes non-lin\u00e9aires. Int\u00e9gration et diff\u00e9rentiation num\u00e9rique. R\u00e9solution de syst\u00e8mes d\u2019\u00e9quations diff\u00e9rentielles. R\u00e9solution de syst\u00e8mes d\u2019EDP. Analyse statistique. Transform\u00e9e de Fourier. Diagonalisation. Calcul de valeurs propres. item Calcul de vecteurs propres. ... Langages de programmation Fortran : Id\u00e9al pour le calcul intensif. C : le plus proche du \"hardware\". IDL : Courant en astrophysique. Java : Ind\u00e9pendant de la machine (portabilit\u00e9). Shell : Scripting de base. Autre : C++, python, Mathematica, etc .... A choisir en fonction de la tache \u00e0 r\u00e9aliser, et non en fonction des habitudes. Maths-Info (ENSAM) CMN 6 septembre 2011 6 / 42 Introduction Sources d\u2019erreurs Qu\u2019est-ce qu\u2019un bon algorithme? Afin de choisir le meilleur algorithme possible, il faut pouvoir les comparer. Un bon algorithme est : le moins co\u00fbteux possible en place m\u00e9moire, le moins co\u00fbteux possible en temps de calcul : c\u2019est-\u00e0-dire qui minimise le nombre d\u2019op\u00e9rations n\u00e9cessaires. C\u2019est ce qu\u2019on appelle un probl\u00e8me de complexit\u00e9. le plus stable possible, ie le moins sensible aux erreurs d\u2019arrondi que nous venons d\u2019\u00e9voquer, le plus pr\u00e9cis possible : la solution approch\u00e9e obtenue est-elle proche ou loin de la solution exacte. C\u2019est ce qu\u2019on appelle l\u2019estimation d\u2019erreur. Exemple : Calcul du d\u00e9terminant d\u2019une matrice N \u00d7 N La m\u00e9thode math\u00e9matique de Cramer n\u00e9cessite N \u00d7 N ! op\u00e9rations \u00e9l\u00e9mentaires ( N ! additions et ( N \u2212 1) \u00d7 N ! multiplications). Prenons N = 50, sachant que 50 \u00d7 50! = 15.1055, et qu\u2019un ordinateur peut faire environ 20 GFlops (ie 20 milliards d\u2019op\u00e9rations \u00e0 la seconde), il faudrait quand m\u00eame environ 1050 ans pour faire ce calcul. Les quatre principales sources d\u2019erreurs : erreurs de mod\u00e9lisation, erreurs sur les donn\u00e9es, erreurs dues \u00e0 la repr\u00e9sentation des nombres sur ordinateur, erreurs de troncature ou de discr\u00e9tisation. Exemple 1 Soit la suite d\u00e9finie par : xn +1 = 4 xn (1 \u2212 xn ) On peut la programmer de deux fa\u00e7ons : x 1 = 4 \u2217 x 1 \u2217(1.0 \u2212 x 1) ; x 2 = 4 \u2217 x 2 \u2212 4 \u2217 x 2 \u2217 x 2 ; \"Normalement\", on doit trouver la m\u00eame chose \"math\u00e9matiquement\", mais les op\u00e9rations ne sont pas faites dans le m\u00eame ordre en machine. Exemple 2 Soit \u00e0 r\u00e9soudre l\u2019\u00e9quation : x 2 + 2 bx \u2212 1 = 0 O\u00f9 b peut \u00eatre \"tr\u00e8s grand\". On d\u221aemande de calculer la solution positive : x + = \u2212 b + b 2 + 1 Comment faut-il la programmer? La aussi, deux possibilit\u00e9s : \u221a x = \u2212 b + b \u2217 b + 1.0; x = \u221a1.0 b + b \u2217 b +1. \u00c9quivalentes math\u00e9matiquement. Exemple 3 Soit \u00e0 calculer, pour n fix\u00e9 : S = n 1 Il y a (au moins) deux fa\u00e7ons n i =1 i d\u2019\u00e9crire la boucle : for (i=1; i<=n; i++) x = x + 1.0/i; for (i=n; i>=1; i\u2013) x = x + 1.0/i; Sans oublier d\u2019initialiser x \u00e0 0 \u00e9videmment. Ici aussi les math\u00e9matiques sont \u00e9quivalentes. Maths-Info (ENSAM) CMN 12 septembre 2011 12 / 42 Introduction Erreurs de mod\u00e9lisation La mod\u00e9lisation c\u2019est : L\u2019identification des diff\u00e9rents facteurs agissant dans le ph\u00e9nom\u00e8ne (physique, biologique, \u00e9conomique , etc) \u00e0 l\u2019\u00e9tude. L\u2019identification et r\u00e9pr\u00e9sentation math\u00e9matique des relations entre les facteurs : \u00e9criture des \u201cformules/\u00e9quations\u201d repr\u00e9sentants ces relations. Les erreurs de mod\u00e9lisation peuvent provenir de l\u2019\u00e9tape de \"math\u00e9matisation\" i.e. simplification ou mauvaise description de la relation entre diff\u00e9rents facteurs lors de la mise en \u00e9quations pour r\u00e9duire le degr\u00e9 de complexit\u00e9 d\u2019un ph\u00e9nom\u00e8me physique, on est souvent amen\u00e9 \u00e0 simplifier le syst\u00e8me d\u2019\u00e9quations, ce qui revient \u00e0 n\u00e9gliger certaines composantes de la r\u00e9alit\u00e9 physique. Solution : Un choix convenable du mod\u00e8le math\u00e9matique. Maths-Info (ENSAM) CMN 14 septembre 2011 14 / 42 Introduction Erreurs sur les donn\u00e9es Les erreurs sur les donn\u00e9es proviennent g\u00e9n\u00e9ralement de l\u2019impr\u00e9cision des mesures physiques qui sont utilis\u00e9es dans l\u2019algorithme. Solution : Ces erreurs peuvent g\u00e9n\u00e9ralement \u00eatre r\u00e9duites en am\u00e9liorant la pr\u00e9cision des mesures. Remarque Il est possible d\u2019\u00e9tudier l\u2019influence de ces erreurs sur le r\u00e9sultat final, par exemple \u00e0 l\u2019aide de la notion de conditionnement (sensibilit\u00e9 aux erreurs). Dans la suite de ce cours, nous ne nous int\u00e9resserons pas aux erreurs de mod\u00e9lisation ni \u00e0 celles sur les donn\u00e9es. Repr\u00e9sentation des nombres sur ordinateur Erreur relative et erreur absolue D\u00e9finition 1 Soit x un nombre r\u00e9el et x \u02dc une approximation de x . L\u2019erreur absolue : \u2206 x = | x \u2212 x \u02dc| (mesure de l\u2019erreur) \u2206 x L\u2019erreur relative : (importance de l\u2019erreur). | x | D\u00e9finition 2 Si m est le plus petit entier sign\u00e9 tel que \u2206 x \u2264 0.5 \u00d7 10 m alors le chiffre correspondant \u00e0 la mi\u00e8me puissance de 10 (et tous ceux \u00e0 sa gauche jusqu\u2019au dernier non-nul) sont dit significatifs. Exemple Si x = \u03c0 et x \u02dc = 3.1428, d\u2019o\u00f9 \u2206 x = 0.12 10\u22122 < 0.5 10\u22122. Donc le chiffre des centi\u00e8mes est significatif, soit le chiffre 4 dans 3.1428 et on a en tout 3 chiffres significatifs (3.14). Repr\u00e9sentation des nombres sur ordinateur Erreurs de repr\u00e9sentation des nombres L\u2019ordinateur doit repr\u00e9senter les nombres dans un syst\u00e8me qui lui permette d\u2019ex\u00e9cuter les op\u00e9rations souhait\u00e9es efficacement. La structure interne des ordinateurs s\u2019appuie g\u00e9n\u00e9ralement sur le syst\u00e8me binaire : repr\u00e9sentation des nombres en base 2. Les calculs sont g\u00e9n\u00e9ralement effectu\u00e9s en base 2, et les interactions avec l\u2019usager affich\u00e9s en base 10. D\u00e9cimal binaire (100)10 = 1 \u00d7 102 + 0 \u00d7 10 + 0 \u00d7 100 1 1 \u00d7 64 + 1 \u00d7 32 + 0 \u00d7 16 + 0 \u00d7 8 + 1 \u00d7 4 + 0 \u00d7 2 + 0 \u00d7 1 1 \u00d7 26 + 1 \u00d7 25 + 0 \u00d7 24 + 0 \u00d7 23 + 1 \u00d7 22 + 0 \u00d7 21 + 0 \u00d7 20 (1100100)2 (0.3)10 = (0.010 0110001100 ...)2 \u2190 fraction p\u00e9riodique en binaire! Repr\u00e9sentation des nombres sur ordinateur Longueur de mots : source d\u2019erreur Sur un ordinateur l\u2019unit\u00e9 d\u2019information de base ou bit prend la valeur 0 ou 1. On regroupe les bits en mots de longueur variable (8, 16, 32 ou 64 sont les plus courants). Les nombres r\u00e9els sont repr\u00e9sent\u00e9s \u00e0 l\u2019aide de ces mots. La capacit\u00e9 m\u00e9moire est finie par construction. Il est donc n\u00e9cessaire de repr\u00e9senter les nombres r\u00e9els sous forme approch\u00e9e. Cela entra\u00eene un certain nombre d\u2019erreurs. Le fait d\u2019utiliser un nombre limit\u00e9 de bits pour repr\u00e9senter un nombre r\u00e9el a des cons\u00e9quences importantes. Pour repr\u00e9senter les nombres r\u00e9els on recourt g\u00e9n\u00e9ralement \u00e0 La troncature \u00e0 N chiffres : on retranche les chiffres \u00e0 partir de la position N + 1. L\u2019arrondi \u00e0 N chiffres : on ajoute 5 au ( N + 1)i\u00e8me chiffre de la mantisse avant d\u2019effectuer la troncature. Repr\u00e9sentation des nombres sur ordinateur Les nombres naturels Nombres Entiers La premi\u00e8re codification des nombres consiste \u00e0 les coder de fa\u00e7on naturelle sur les mots connus au niveau de la machine, 8, 16, 32 ou 64 bits la limitation \u00e9tant la valeur maximale que l\u2019on peut stocker. On parle alors de repr\u00e9sentation en champs fixe. Par nombre naturel, on entend les nombres entiers, positifs ou nuls 1 octet pourra coder un nombre de (00000000)2 \u2192 (11111111)2 (0 \u2192 255) 1 mot de 16 bits : de 0 \u2192 216 \u2212 1 (65535) 1 mot de 32 bits : de 0 \u2192 232 \u2212 1 (4 294 967 295) La limite reste toujours la taille du mot manipul\u00e9 Repr\u00e9sentation des nombres sur ordinateur Les nombres relatifs La repr\u00e9sentation des nombres n\u00e9gatifs est r\u00e9alis\u00e9 gr\u00e2ce au bit de poids fort \"bit de gauche\". On parle \u00e9galement d\u2019entiers sign\u00e9s. Nombres positifs \u2192 le bit de poids fort est 0 Nombres n\u00e9gatifs \u2192 le bit de poids fort est 1 Les autres bits contiennent la valeur absolue du nombre Exemple sur un octet Inconv\u00e9nient : Pour r\u00e9aliser des op\u00e9rations entre nombres sign\u00e9s, il faut faire un traitement particulier du bit de signe. Le r\u00e9sultat final ne pouvant \u00eatre obtenu de fa\u00e7on simple (addition ou soustraction des deux nombres). D\u2019o\u00f9 l\u2019utilisation du compl\u00e9ment \u00e0 2. Repr\u00e9sentation des nombres sur ordinateur Repr\u00e9sentation par le compl\u00e9ment \u00e0 2 Repr\u00e9sentation par le compl\u00e9ment \u00e0 1 Le compl\u00e9ment \u00e0 1 (not\u00e9 C1) est \u00e9galement appel\u00e9 compl\u00e9ment logique, il consiste \u00e0 inverser chaque bit (0 \u2192 1 et 1 \u2192 0) Repr\u00e9sentation par le compl\u00e9ment \u00e0 2 Le compl\u00e9ment \u00e0 2 (not\u00e9 C2) est \u00e9galement appel\u00e9 compl\u00e9ment vrai, il consiste \u00e0 ajouter 1 en binaire au compl\u00e9ment \u00e0 1. L\u2019entier positif est repr\u00e9sent\u00e9 en binaire naturel. L\u2019entier n\u00e9gatif est repr\u00e9sent\u00e9 par le compl\u00e9ment \u00e0 2 de son oppos\u00e9. Maths-Info (ENSAM) CMN 22 septembre 2011 22 / 42 Repr\u00e9sentation des nombres sur ordinateur Exemple Une soustraction a \u2212 b devient une addition a + (\u2212 b ). (\u2212 b ) \u00e9tant le compl\u00e9ment \u00e0 2 de b Si le bit de poids fort est 0, le r\u00e9sultat est positif, et si le bit de poids fort est 1, le r\u00e9sultat est n\u00e9gatif Pour conna\u00eetre la valeur absolue du r\u00e9sultat n\u00e9gatif, il suffit de faire le compl\u00e9ment \u00e0 2 : En effet |5 \u2212 12| = (0000000111)2 = (7)10 Les limites des nombres Les nombres sont cod\u00e9s de fa\u00e7on fixe, ce qui fait qu\u2019ils ont une limite li\u00e9e au nombre de bis qui les repr\u00e9sentent : En synth\u00e8se, si le nombre de bits est n , les valeurs vont de \u22122 n \u00e0 2 n \u2212 1 Maths-Info (ENSAM) CMN 24 septembre 2011 24 / 42 Repr\u00e9sentation des nombres sur ordinateur Les nombre r\u00e9els : repr\u00e9sentationen virgule flottante On se donne un entier b \u2265 2 appel\u00e9 base de num\u00e9ration. On choisit aussi un entier p \u2265 2 appel\u00e9 pr\u00e9cision ou nombre de chiffres significatif. On se donne aussi deux entiers emax \u2265 2 et emin \u2264 \u22122. Un nombre flottant normalis\u00e9 est alors un nombre de la forme x = (\u22121) s \u00d7 m \u00d7 be o\u00f9 s \u2208 {0,1} et (\u22121) s est le signe de x . m est appel\u00e9e La mantisse, elle est \u00e9crite sous la forme d\u2019un nombre avec virgule fixe et poss\u00e9dant un nombre maximum de p chiffres significatifs p m = 0. d 1 d 2... dp = dk b \u2212 k , k =1 avec 1 \u2264 d 1 \u2264 b \u2212 1 (mantisse normalis\u00e9e) et 0 \u2264 dk \u2264 b \u2212 1. L\u2019entier e , appel\u00e9 exposant , v\u00e9rifie emin \u2264 e \u2264 emax . On v\u00e9rifie que 1 \u2264 m \u2264 1 \u2212 b \u2212 p \u03bb = bemin \u22121 \u2264 | xb | \u2264 \u00b5 = (1 \u2212 b \u2212 p e) b t emax . L\u2019ensemble des flottants normalis\u00e9s est not\u00e9 F ( b , p , emin , emax ) Par exemple, prenons b = 10, p = 5 et emax = \u2212 emin = 100. Le rationnel 0.000000000000000000000123est dans F (10, 5, \u2212100, 100) et s\u2019\u00e9crit x = (\u22121)0 \u00d7 1.2300\u00d7 10\u221222 . Notons que 0 n\u2019est pas un entier flottant normalis\u00e9. On pose = b 1\u2212 p et on v\u00e9rifie sans peine le lemme suivant. Lemme 1 Soit x > 0 un entier flottant normalis\u00e9 et y le suivant (le plus petit entier flottant normalis\u00e9 plus grand que x ) s\u2019il existe. Alors y \u2212 x v\u00e9rifie | x | \u2264 y \u2212 x \u2264 x b Une fois choisis b , p , emin et emax on se donne une application d\u2019arrondi \u03c6 : R \u2192 F ( b , p , emin , emax ) { OVERFLOW , UNDERFLOW } jouissant des propri\u00e9t\u00e9s suivantes : \u03c6( x ) = OVERFLOW si et seulement si | x | > \u00b5 ; \u03c6( x ) = UNDERFLOW si et seulement si | x | < \u03bb ; \u03c6 est croissante sur [\u03bb,\u00b5] et sur [\u2212\u00b5, \u2212\u03bb]; La restriction de phi \u00e0 F ( b , p , emin , emax ) est l\u2019identit\u00e9. Le fait d\u2019utiliser un nombre limit\u00e9 de bits pour repr\u00e9senter un nombre r\u00e9el a des cons\u00e9quences importantes : Cette repr\u00e9sentation introduit une erreur (troncature ou arrondi) qui peut avoir un impact important sur la pr\u00e9cision des r\u00e9sultats. Quelque soit le nombre de bits utilis\u00e9s, il existe un plus petit et un plus grand nombre (positif et n\u00e9gatif) repr\u00e9sentables . Il existe donc un intervalle fini hors duquel on a un d\u00e9bordement (overflow) ou un sous-d\u00e9passement (underflow). Dans ce cas les operations arithm\u00e9tique n\u2019ont plus de sens. A l\u2019int\u00e9rieur de cet intervalle fini, seul un nombre fini de nombres sont repr\u00e9sentables exactement. La repr\u00e9sentation en virgule flottante induit une erreur relative qui d\u00e9pend du nombre de bits de la mantisse, de l\u2019utilisation de la troncature ou de l\u2019arrondi, ainsi que du nombre x \u00e0 repr\u00e9senter. D\u00e9finition La pr\u00e9cision machine est la plus grande erreur relative commise en repr\u00e9sentant un nombre r\u00e9el sur ordinateur : \u2206 x precision machine = maximum | x | 1\u2212 N En utilisant la troncature, on a : \u03b5 m = b En utilisant l\u2019arrondi, on a : \u03b5 = \u03b5 m /2 = b 1\u2212 N /2. Remarque : En r\u00e9alit\u00e9 la pr\u00e9cision machine est au maximum \u00e9gale \u00e0 \u03b5 m ou \u03b5 mais dans la pratique on confond la pr\u00e9cision avec cette borne. La convention IEEE-754 Norme visant \u00e0 standardiser la repr\u00e9sentation des nombres sur les ordinateurs. En particulier elle impose le nombre de bits pour la mantisse, et l\u2019exposant pour les nombres reels \u00e0 32 bits (simple precision) et les reels 64 bits (double precision). Fait en sorte que l\u2019on peut determiner la precision machine ainsi que le plus grand et plus petit reels (simple et double precision) repr\u00e9sentable ind\u00e9pendemment de l\u2019ordinateur . simple precision double precision \u03b5 m 0.119 \u00d7 10\u22126 0.222 \u00d7 10\u221215 plus petit r\u00e9el (normalis\u00e9e) 1.2 \u00d7 10\u221238 2.2 \u00d7 10\u2212308 plus petit r\u00e9el (non-normalis\u00e9e) 1.4 \u00d7 10\u221245 4.9 \u00d7 10\u2212324 plus grand r\u00e9el 3.4 \u00d7 1038 1.8 \u00d7 10308 Maths-Info (ENSAM) CMN 30 septembre 2011 30 / 42 Repr\u00e9sentation des nombres sur ordinateur IEEE-754 D\u00e9calage de l\u2019exposant L\u2019exposant \u00e9tant repr\u00e9sent\u00e9 par un nombre sign\u00e9 (compl\u00e9ment \u00e0 2), la comparaison entre les nombres flottants devient un peu plus difficile. Pour remedier \u00e0 ce probl\u00e8me, l\u2019exposant est d\u00e9cal\u00e9, afin de le stocker sous forme d\u2019un nombre non sign\u00e9. Ce d\u00e9calage est de 2 e \u22121 \u2212 1 ( e repr\u00e9sente le nombre de bits de l\u2019exposant); il s\u2019agit donc d\u2019une valeur constante une fois que le nombre de bits e est fix\u00e9 : valeur = signe \u00d7 1, mantisse \u00d7 2( exposant \u2212 decalage ) Format simple pr\u00e9cision (32 bits) Un nombre flottant simple pr\u00e9cision est stock\u00e9 dans un mot de 32 bit : 1 bit de signe, 8 bits pour l\u2019exposant et 23 pour la mantisse. L\u2019exposant est donc d\u00e9cal\u00e9 de 28\u22121 \u2212 1 = 127 dans ce cas. L\u2019exposant -127 (qui est d\u00e9cal\u00e9 vers la valeur 0) est r\u00e9serv\u00e9 pour z\u00e9ro et les nombres d\u00e9normalis\u00e9s, tandis que l\u2019exposant 128 (d\u00e9cal\u00e9 vers 255) est r\u00e9serv\u00e9 pour coder les infinis et les NaNs. Exemple1 Pour 0 01111100 01000000000000000000000,l\u2019exposant est 124 \u2212 127 = \u22123 et la partie significative est 1,01 soit 1,25 en d\u00e9cimal (1 x 20 + 0 x 2\u22121 + 1 x 2\u22122); le nombre repr\u00e9sent\u00e9 est donc +1,25 x 2\u22123 soit +0, 15625. Exemple2 Codons le nombre -118,625 en utilisant IEEE 754. 1 C\u2019est un nombre n\u00e9gatif, le signe est donc \"1\". 1 Nous \u00e9crivons le nombre (sans le signe) en binaire. Nous obtenons 1110110,101. 1 Nous d\u00e9calons la virgule vers la gauche, de fa\u00e7on \u00e0 ne laisser qu\u2019un 1 sur sa gauche : 1110110,101 (bin) = 1,110110101 (bin) x C\u2019est un nombre flottant normalis\u00e9 : la mantisse est la partie \u00e0 droite de la virgule, remplie de 0 vers la droite pour obtenir 23 bits. Cela donne 110 1101 0100 0000 0000 0000 (on omet le 1 avant la virgule, qui est implicite). 1 L\u2019exposant est \u00e9gal \u00e0 6, et nous devons le convertir en binaire et le d\u00e9caler. Pour le format 32-bit IEEE 754, le d\u00e9calage est 28\u22121 \u2212 1 = 127. Donc 6 + 127 = 133 (dec) = 1000 0101 (bin). -118,625 (dec) = 1100 0010 1110 1101 0100 0000 0000 0000 (bin) C2ED4000 (hexa) Format double pr\u00e9cision (64 bits) Le format double pr\u00e9cision est identique au simple pr\u00e9cision, mis \u00e0 part le fait que les champs sont plus grands. En effet, il poss\u00e8de 52 bits de mantisse, et 11 bits d\u2019exposant. La mantisse est tr\u00e8s \u00e9largie, alors que l\u2019exposant est peu \u00e9largi. Ceci est d\u00fb au fait que, selon les cr\u00e9ateurs du standard, la pr\u00e9cision est plus importante que l\u2019amplitude. Les NaNs et les infinis sont repr\u00e9sent\u00e9s en mettant tous les bits de l\u2019exposant \u00e0 1 (2047). Pour les nombres normalis\u00e9s, le d\u00e9calage de l\u2019exposant est +1023. Maths-Info (ENSAM) CMN 35 septembre 2011 35 / 42 Arithm\u00e9tique flottante Mod\u00e8le de l\u2019arithm\u00e9tique flottante Les op\u00e9rations \u00e9l\u00e9mentaires sont effectu\u00e9es en arithm\u00e9tique flottante x + y \u2212\u2192 fl ( fl ( x ) + fl ( y ) ) x \u2212 y \u2212\u2192 fl ( fl ( x ) \u2212 fl ( y ) ) de la mani\u00e8re suivante : Attention : x \u00f7 y \u2212\u2192 fl ( fl ( x ) \u00f7 fl ( y ) ) x \u00d7 y \u2212\u2192 fl ( fl ( x ) \u00d7 fl ( y ) ) plusieurs propri\u00e9t\u00e9s de l\u2019arithm\u00e9tique : associativit\u00e9, distributivit\u00e9, etc ne sont plus valides (pas toujours) en arithm\u00e9tique flottante! Maths-Info (ENSAM) CMN 36 septembre 2011 36 / 42 Arithm\u00e9tique flottante Associativit\u00e9 Par exemple : supposons que les r\u00e9els soient calcul\u00e9s avec n = 3 chiffres significatifs et arrondis \u00e0 la d\u00e9cimale la plus proche. Soient x = 8,22, y = 0,00317, z = 0,00432 ( x + y ) + z = x + ( y + z ) Arithm\u00e9tique flottante Distributivit\u00e9 Encore avec n =3 x \u00d7 ( y + z ) = x \u00d7 y + x \u00d7 z 122 \u00d7 (333 + 695) = fl ( 0,122 103 \u00d7 fl ( 0,333 103 + 0,695 103 )) fl ( 0,122 103 \u00d7 fl ( 1,028 103 )) fl ( 0,122 103 \u00d7 fl ( 0,103 104 )) fl ( 0,012566 107 )) 0,126 106 (122 \u00d7 333)+ (122 \u00d7 695) = fl ( fl ( 0,122 103 \u00d7 0,333 103 ) + fl ( 0,122 103 \u00d7 0,695 103 )) fl ( fl ( 0,040626 106 + fl ( 0,08479 106 ) fl ( 0,406 105 + 0,848 105 ) fl ( 1,254 105 ) 0,125 106 Il ya donc une diff\u00e9rence entre les deux r\u00e9sultats. Arithm\u00e9tique flottante Attention \u00e0 l\u2019exposant!!! Il faut \u00eatre prudent avec l\u2019addition et la soustraction. Lorsque les exposants ne sont pas les m\u00eames il est n\u00e9cessaire de d\u00e9caler la mantisse avant d\u2019effectuer l\u2019addition ou la soustraction. Pour n = 4 0,4035 106 + 0,1978 104 = fl ( 0,4035 106 + 0,1978 104 ) fl ( 0,4035 106 + 0,001978 106 ) fl ( 0,405478 106 ) 0,4055 106 et 0,56789 104 \u2212 0,1234321 106 = fl ( 0,5679 104 \u2212 0,1234 106 ) fl ( 0,005679 106 \u2212 0,1234 106 ) fl ( \u22120,11772 106 ) \u22120,1177 106 Arithm\u00e9tique flottante Ph\u00e9nom\u00e8ne de cancellation Il existe d\u2019autre part, un certain nombre d\u2019op\u00e9rations risqu\u00e9es. Soustraire deux nombres presque identiques : \u221a 7001 \u2212 7000 = 0,8367 102 \u2212 0,8367 102 0,000 100 si n = 4 \u221a 7001 \u2212 7000 = 0,83672 102 \u2212 0,83666 102 0,6 10\u22122 si n = 5 Dans ce cas-ci on peut rem\u00e9dier \u00e0 cette difficult\u00e9 en \u00e9vitant la soustraction des racines : \u221a x \u2212 y x \u2212 y = \u221a \u221a x + y et on trouve 0,5977 10\u22122 au lieu de 0 pour n = 4. Arithm\u00e9tique flottante Conclusion L\u2019ordre dans lequel on fait les op\u00e9rations et le nombre d\u2019op\u00e9rations ont un impact important sur la pr\u00e9cision du r\u00e9sultats. Ainsi on devrait \u201dtoujours\u201c : \u00e9viter les op\u00e9rations avec des nombres tr\u00e8s diff\u00e9rents en ordre de grandeurs, \u00e9viter si possibles les soustractions avec des nombre relativement proche, on devrait faire les sommes en ordre d\u00e9croissant. Maths-Info (ENSAM) CMN 42 septembre 2011 42 / 42","title":"heartbeat4palestine"},{"location":"#heartbeat4palestine","text":"For more information contact ABDELHADI MAHBOUB. \ufeffChapitre 1 Repr\u00e9sentation des nombres sur ordinateur ENSAM-Mekn\u00e8s Universit\u00e9 Moulay Ismail - Mekn\u00e8s 28 septembre 2011 1 Introduction 1 Repr\u00e9sentation des nombres sur ordinateur 1 Arithm\u00e9tique flottante Maths-Info (ENSAM) CMN 2 septembre 2011 2 / 42 Introduction Analyse num\u00e9rique L\u2019analyse Num\u00e9rique est une sp\u00e9cialit\u00e9 r\u00e9cente des math\u00e9matiques, elle s\u2019est d\u00e9velopp\u00e9e avec l\u2019apparition des ordinateurs. Son objet essentiel est d\u2019\u00e9crire les programmes permettant d\u2019effectuer les op\u00e9rations n\u00e9cessaires pour r\u00e9soudre num\u00e9riquement un probl\u00e8me donn\u00e9. Les m\u00e9thodes ont un \"co\u00fbt\", li\u00e9 d\u2019une part au temps de calcul, ie au nombre d\u2019op\u00e9rations \u00e9l\u00e9mentaires (additions, soustractions, multiplications et divisions) \u00e0 faire, et d\u2019autre part \u00e0 l\u2019espace m\u00e9moire n\u00e9cessaire pour stocker les donn\u00e9es et les r\u00e9sultats. L\u2019ordinateur ne fait pas de calculs exacts (\u00e0 cause du mode de repr\u00e9sentation des nombres). Ceci constitue un inconv\u00e9nient car cela provoque des erreurs d\u2019arrondis et de troncature. Pour un grand nombre de probl\u00e8mes, le seul moyen de calculer la solution, si elle existe, est de l\u2019approcher num\u00e9riquement. Un algorithme c\u2019est une d\u00e9marche pour obtenir une solution (impliquant des simplifications, ajout/retrait d\u2019hypoth\u00e8ses sur le mod\u00e8le, etc) ET l\u2019implementation sur ordinateur de cette d\u00e9marche. Objectifs de l\u2019analyse num\u00e9rique : proposer et d\u00e9velopper des algorithmes (m\u00e9thodes d\u2019approximation) pour calculer une solution approch\u00e9e, contr\u00f4ler les diverses sources d\u2019erreurs, propres \u00e0 l\u2019approximation num\u00e9rique, \u00e9valuer la pertinence et la valeur de diff\u00e9rents algorithmes (estimer leurs performances) pouvant \u00eatre utilis\u00e9s pour r\u00e9soudre le m\u00eame probl\u00e8me afin de s\u00e9lectionner les meilleurs . Quelques probl\u00e8mes typiques Interpolation - Extrapolation. R\u00e9solution de syst\u00e8mes lin\u00e9aires. R\u00e9solution de syst\u00e8mes non-lin\u00e9aires. Int\u00e9gration et diff\u00e9rentiation num\u00e9rique. R\u00e9solution de syst\u00e8mes d\u2019\u00e9quations diff\u00e9rentielles. R\u00e9solution de syst\u00e8mes d\u2019EDP. Analyse statistique. Transform\u00e9e de Fourier. Diagonalisation. Calcul de valeurs propres. item Calcul de vecteurs propres. ... Langages de programmation Fortran : Id\u00e9al pour le calcul intensif. C : le plus proche du \"hardware\". IDL : Courant en astrophysique. Java : Ind\u00e9pendant de la machine (portabilit\u00e9). Shell : Scripting de base. Autre : C++, python, Mathematica, etc .... A choisir en fonction de la tache \u00e0 r\u00e9aliser, et non en fonction des habitudes. Maths-Info (ENSAM) CMN 6 septembre 2011 6 / 42 Introduction Sources d\u2019erreurs Qu\u2019est-ce qu\u2019un bon algorithme? Afin de choisir le meilleur algorithme possible, il faut pouvoir les comparer. Un bon algorithme est : le moins co\u00fbteux possible en place m\u00e9moire, le moins co\u00fbteux possible en temps de calcul : c\u2019est-\u00e0-dire qui minimise le nombre d\u2019op\u00e9rations n\u00e9cessaires. C\u2019est ce qu\u2019on appelle un probl\u00e8me de complexit\u00e9. le plus stable possible, ie le moins sensible aux erreurs d\u2019arrondi que nous venons d\u2019\u00e9voquer, le plus pr\u00e9cis possible : la solution approch\u00e9e obtenue est-elle proche ou loin de la solution exacte. C\u2019est ce qu\u2019on appelle l\u2019estimation d\u2019erreur. Exemple : Calcul du d\u00e9terminant d\u2019une matrice N \u00d7 N La m\u00e9thode math\u00e9matique de Cramer n\u00e9cessite N \u00d7 N ! op\u00e9rations \u00e9l\u00e9mentaires ( N ! additions et ( N \u2212 1) \u00d7 N ! multiplications). Prenons N = 50, sachant que 50 \u00d7 50! = 15.1055, et qu\u2019un ordinateur peut faire environ 20 GFlops (ie 20 milliards d\u2019op\u00e9rations \u00e0 la seconde), il faudrait quand m\u00eame environ 1050 ans pour faire ce calcul. Les quatre principales sources d\u2019erreurs : erreurs de mod\u00e9lisation, erreurs sur les donn\u00e9es, erreurs dues \u00e0 la repr\u00e9sentation des nombres sur ordinateur, erreurs de troncature ou de discr\u00e9tisation. Exemple 1 Soit la suite d\u00e9finie par : xn +1 = 4 xn (1 \u2212 xn ) On peut la programmer de deux fa\u00e7ons : x 1 = 4 \u2217 x 1 \u2217(1.0 \u2212 x 1) ; x 2 = 4 \u2217 x 2 \u2212 4 \u2217 x 2 \u2217 x 2 ; \"Normalement\", on doit trouver la m\u00eame chose \"math\u00e9matiquement\", mais les op\u00e9rations ne sont pas faites dans le m\u00eame ordre en machine. Exemple 2 Soit \u00e0 r\u00e9soudre l\u2019\u00e9quation : x 2 + 2 bx \u2212 1 = 0 O\u00f9 b peut \u00eatre \"tr\u00e8s grand\". On d\u221aemande de calculer la solution positive : x + = \u2212 b + b 2 + 1 Comment faut-il la programmer? La aussi, deux possibilit\u00e9s : \u221a x = \u2212 b + b \u2217 b + 1.0; x = \u221a1.0 b + b \u2217 b +1. \u00c9quivalentes math\u00e9matiquement. Exemple 3 Soit \u00e0 calculer, pour n fix\u00e9 : S = n 1 Il y a (au moins) deux fa\u00e7ons n i =1 i d\u2019\u00e9crire la boucle : for (i=1; i<=n; i++) x = x + 1.0/i; for (i=n; i>=1; i\u2013) x = x + 1.0/i; Sans oublier d\u2019initialiser x \u00e0 0 \u00e9videmment. Ici aussi les math\u00e9matiques sont \u00e9quivalentes. Maths-Info (ENSAM) CMN 12 septembre 2011 12 / 42 Introduction Erreurs de mod\u00e9lisation La mod\u00e9lisation c\u2019est : L\u2019identification des diff\u00e9rents facteurs agissant dans le ph\u00e9nom\u00e8ne (physique, biologique, \u00e9conomique , etc) \u00e0 l\u2019\u00e9tude. L\u2019identification et r\u00e9pr\u00e9sentation math\u00e9matique des relations entre les facteurs : \u00e9criture des \u201cformules/\u00e9quations\u201d repr\u00e9sentants ces relations. Les erreurs de mod\u00e9lisation peuvent provenir de l\u2019\u00e9tape de \"math\u00e9matisation\" i.e. simplification ou mauvaise description de la relation entre diff\u00e9rents facteurs lors de la mise en \u00e9quations pour r\u00e9duire le degr\u00e9 de complexit\u00e9 d\u2019un ph\u00e9nom\u00e8me physique, on est souvent amen\u00e9 \u00e0 simplifier le syst\u00e8me d\u2019\u00e9quations, ce qui revient \u00e0 n\u00e9gliger certaines composantes de la r\u00e9alit\u00e9 physique. Solution : Un choix convenable du mod\u00e8le math\u00e9matique. Maths-Info (ENSAM) CMN 14 septembre 2011 14 / 42 Introduction Erreurs sur les donn\u00e9es Les erreurs sur les donn\u00e9es proviennent g\u00e9n\u00e9ralement de l\u2019impr\u00e9cision des mesures physiques qui sont utilis\u00e9es dans l\u2019algorithme. Solution : Ces erreurs peuvent g\u00e9n\u00e9ralement \u00eatre r\u00e9duites en am\u00e9liorant la pr\u00e9cision des mesures. Remarque Il est possible d\u2019\u00e9tudier l\u2019influence de ces erreurs sur le r\u00e9sultat final, par exemple \u00e0 l\u2019aide de la notion de conditionnement (sensibilit\u00e9 aux erreurs). Dans la suite de ce cours, nous ne nous int\u00e9resserons pas aux erreurs de mod\u00e9lisation ni \u00e0 celles sur les donn\u00e9es. Repr\u00e9sentation des nombres sur ordinateur Erreur relative et erreur absolue D\u00e9finition 1 Soit x un nombre r\u00e9el et x \u02dc une approximation de x . L\u2019erreur absolue : \u2206 x = | x \u2212 x \u02dc| (mesure de l\u2019erreur) \u2206 x L\u2019erreur relative : (importance de l\u2019erreur). | x | D\u00e9finition 2 Si m est le plus petit entier sign\u00e9 tel que \u2206 x \u2264 0.5 \u00d7 10 m alors le chiffre correspondant \u00e0 la mi\u00e8me puissance de 10 (et tous ceux \u00e0 sa gauche jusqu\u2019au dernier non-nul) sont dit significatifs. Exemple Si x = \u03c0 et x \u02dc = 3.1428, d\u2019o\u00f9 \u2206 x = 0.12 10\u22122 < 0.5 10\u22122. Donc le chiffre des centi\u00e8mes est significatif, soit le chiffre 4 dans 3.1428 et on a en tout 3 chiffres significatifs (3.14). Repr\u00e9sentation des nombres sur ordinateur Erreurs de repr\u00e9sentation des nombres L\u2019ordinateur doit repr\u00e9senter les nombres dans un syst\u00e8me qui lui permette d\u2019ex\u00e9cuter les op\u00e9rations souhait\u00e9es efficacement. La structure interne des ordinateurs s\u2019appuie g\u00e9n\u00e9ralement sur le syst\u00e8me binaire : repr\u00e9sentation des nombres en base 2. Les calculs sont g\u00e9n\u00e9ralement effectu\u00e9s en base 2, et les interactions avec l\u2019usager affich\u00e9s en base 10. D\u00e9cimal binaire (100)10 = 1 \u00d7 102 + 0 \u00d7 10 + 0 \u00d7 100 1 1 \u00d7 64 + 1 \u00d7 32 + 0 \u00d7 16 + 0 \u00d7 8 + 1 \u00d7 4 + 0 \u00d7 2 + 0 \u00d7 1 1 \u00d7 26 + 1 \u00d7 25 + 0 \u00d7 24 + 0 \u00d7 23 + 1 \u00d7 22 + 0 \u00d7 21 + 0 \u00d7 20 (1100100)2 (0.3)10 = (0.010 0110001100 ...)2 \u2190 fraction p\u00e9riodique en binaire! Repr\u00e9sentation des nombres sur ordinateur Longueur de mots : source d\u2019erreur Sur un ordinateur l\u2019unit\u00e9 d\u2019information de base ou bit prend la valeur 0 ou 1. On regroupe les bits en mots de longueur variable (8, 16, 32 ou 64 sont les plus courants). Les nombres r\u00e9els sont repr\u00e9sent\u00e9s \u00e0 l\u2019aide de ces mots. La capacit\u00e9 m\u00e9moire est finie par construction. Il est donc n\u00e9cessaire de repr\u00e9senter les nombres r\u00e9els sous forme approch\u00e9e. Cela entra\u00eene un certain nombre d\u2019erreurs. Le fait d\u2019utiliser un nombre limit\u00e9 de bits pour repr\u00e9senter un nombre r\u00e9el a des cons\u00e9quences importantes. Pour repr\u00e9senter les nombres r\u00e9els on recourt g\u00e9n\u00e9ralement \u00e0 La troncature \u00e0 N chiffres : on retranche les chiffres \u00e0 partir de la position N + 1. L\u2019arrondi \u00e0 N chiffres : on ajoute 5 au ( N + 1)i\u00e8me chiffre de la mantisse avant d\u2019effectuer la troncature. Repr\u00e9sentation des nombres sur ordinateur Les nombres naturels Nombres Entiers La premi\u00e8re codification des nombres consiste \u00e0 les coder de fa\u00e7on naturelle sur les mots connus au niveau de la machine, 8, 16, 32 ou 64 bits la limitation \u00e9tant la valeur maximale que l\u2019on peut stocker. On parle alors de repr\u00e9sentation en champs fixe. Par nombre naturel, on entend les nombres entiers, positifs ou nuls 1 octet pourra coder un nombre de (00000000)2 \u2192 (11111111)2 (0 \u2192 255) 1 mot de 16 bits : de 0 \u2192 216 \u2212 1 (65535) 1 mot de 32 bits : de 0 \u2192 232 \u2212 1 (4 294 967 295) La limite reste toujours la taille du mot manipul\u00e9 Repr\u00e9sentation des nombres sur ordinateur Les nombres relatifs La repr\u00e9sentation des nombres n\u00e9gatifs est r\u00e9alis\u00e9 gr\u00e2ce au bit de poids fort \"bit de gauche\". On parle \u00e9galement d\u2019entiers sign\u00e9s. Nombres positifs \u2192 le bit de poids fort est 0 Nombres n\u00e9gatifs \u2192 le bit de poids fort est 1 Les autres bits contiennent la valeur absolue du nombre Exemple sur un octet Inconv\u00e9nient : Pour r\u00e9aliser des op\u00e9rations entre nombres sign\u00e9s, il faut faire un traitement particulier du bit de signe. Le r\u00e9sultat final ne pouvant \u00eatre obtenu de fa\u00e7on simple (addition ou soustraction des deux nombres). D\u2019o\u00f9 l\u2019utilisation du compl\u00e9ment \u00e0 2. Repr\u00e9sentation des nombres sur ordinateur Repr\u00e9sentation par le compl\u00e9ment \u00e0 2 Repr\u00e9sentation par le compl\u00e9ment \u00e0 1 Le compl\u00e9ment \u00e0 1 (not\u00e9 C1) est \u00e9galement appel\u00e9 compl\u00e9ment logique, il consiste \u00e0 inverser chaque bit (0 \u2192 1 et 1 \u2192 0) Repr\u00e9sentation par le compl\u00e9ment \u00e0 2 Le compl\u00e9ment \u00e0 2 (not\u00e9 C2) est \u00e9galement appel\u00e9 compl\u00e9ment vrai, il consiste \u00e0 ajouter 1 en binaire au compl\u00e9ment \u00e0 1. L\u2019entier positif est repr\u00e9sent\u00e9 en binaire naturel. L\u2019entier n\u00e9gatif est repr\u00e9sent\u00e9 par le compl\u00e9ment \u00e0 2 de son oppos\u00e9. Maths-Info (ENSAM) CMN 22 septembre 2011 22 / 42 Repr\u00e9sentation des nombres sur ordinateur Exemple Une soustraction a \u2212 b devient une addition a + (\u2212 b ). (\u2212 b ) \u00e9tant le compl\u00e9ment \u00e0 2 de b Si le bit de poids fort est 0, le r\u00e9sultat est positif, et si le bit de poids fort est 1, le r\u00e9sultat est n\u00e9gatif Pour conna\u00eetre la valeur absolue du r\u00e9sultat n\u00e9gatif, il suffit de faire le compl\u00e9ment \u00e0 2 : En effet |5 \u2212 12| = (0000000111)2 = (7)10 Les limites des nombres Les nombres sont cod\u00e9s de fa\u00e7on fixe, ce qui fait qu\u2019ils ont une limite li\u00e9e au nombre de bis qui les repr\u00e9sentent : En synth\u00e8se, si le nombre de bits est n , les valeurs vont de \u22122 n \u00e0 2 n \u2212 1 Maths-Info (ENSAM) CMN 24 septembre 2011 24 / 42 Repr\u00e9sentation des nombres sur ordinateur Les nombre r\u00e9els : repr\u00e9sentationen virgule flottante On se donne un entier b \u2265 2 appel\u00e9 base de num\u00e9ration. On choisit aussi un entier p \u2265 2 appel\u00e9 pr\u00e9cision ou nombre de chiffres significatif. On se donne aussi deux entiers emax \u2265 2 et emin \u2264 \u22122. Un nombre flottant normalis\u00e9 est alors un nombre de la forme x = (\u22121) s \u00d7 m \u00d7 be o\u00f9 s \u2208 {0,1} et (\u22121) s est le signe de x . m est appel\u00e9e La mantisse, elle est \u00e9crite sous la forme d\u2019un nombre avec virgule fixe et poss\u00e9dant un nombre maximum de p chiffres significatifs p m = 0. d 1 d 2... dp = dk b \u2212 k , k =1 avec 1 \u2264 d 1 \u2264 b \u2212 1 (mantisse normalis\u00e9e) et 0 \u2264 dk \u2264 b \u2212 1. L\u2019entier e , appel\u00e9 exposant , v\u00e9rifie emin \u2264 e \u2264 emax . On v\u00e9rifie que 1 \u2264 m \u2264 1 \u2212 b \u2212 p \u03bb = bemin \u22121 \u2264 | xb | \u2264 \u00b5 = (1 \u2212 b \u2212 p e) b t emax . L\u2019ensemble des flottants normalis\u00e9s est not\u00e9 F ( b , p , emin , emax ) Par exemple, prenons b = 10, p = 5 et emax = \u2212 emin = 100. Le rationnel 0.000000000000000000000123est dans F (10, 5, \u2212100, 100) et s\u2019\u00e9crit x = (\u22121)0 \u00d7 1.2300\u00d7 10\u221222 . Notons que 0 n\u2019est pas un entier flottant normalis\u00e9. On pose = b 1\u2212 p et on v\u00e9rifie sans peine le lemme suivant. Lemme 1 Soit x > 0 un entier flottant normalis\u00e9 et y le suivant (le plus petit entier flottant normalis\u00e9 plus grand que x ) s\u2019il existe. Alors y \u2212 x v\u00e9rifie | x | \u2264 y \u2212 x \u2264 x b Une fois choisis b , p , emin et emax on se donne une application d\u2019arrondi \u03c6 : R \u2192 F ( b , p , emin , emax ) { OVERFLOW , UNDERFLOW } jouissant des propri\u00e9t\u00e9s suivantes : \u03c6( x ) = OVERFLOW si et seulement si | x | > \u00b5 ; \u03c6( x ) = UNDERFLOW si et seulement si | x | < \u03bb ; \u03c6 est croissante sur [\u03bb,\u00b5] et sur [\u2212\u00b5, \u2212\u03bb]; La restriction de phi \u00e0 F ( b , p , emin , emax ) est l\u2019identit\u00e9. Le fait d\u2019utiliser un nombre limit\u00e9 de bits pour repr\u00e9senter un nombre r\u00e9el a des cons\u00e9quences importantes : Cette repr\u00e9sentation introduit une erreur (troncature ou arrondi) qui peut avoir un impact important sur la pr\u00e9cision des r\u00e9sultats. Quelque soit le nombre de bits utilis\u00e9s, il existe un plus petit et un plus grand nombre (positif et n\u00e9gatif) repr\u00e9sentables . Il existe donc un intervalle fini hors duquel on a un d\u00e9bordement (overflow) ou un sous-d\u00e9passement (underflow). Dans ce cas les operations arithm\u00e9tique n\u2019ont plus de sens. A l\u2019int\u00e9rieur de cet intervalle fini, seul un nombre fini de nombres sont repr\u00e9sentables exactement. La repr\u00e9sentation en virgule flottante induit une erreur relative qui d\u00e9pend du nombre de bits de la mantisse, de l\u2019utilisation de la troncature ou de l\u2019arrondi, ainsi que du nombre x \u00e0 repr\u00e9senter. D\u00e9finition La pr\u00e9cision machine est la plus grande erreur relative commise en repr\u00e9sentant un nombre r\u00e9el sur ordinateur : \u2206 x precision machine = maximum | x | 1\u2212 N En utilisant la troncature, on a : \u03b5 m = b En utilisant l\u2019arrondi, on a : \u03b5 = \u03b5 m /2 = b 1\u2212 N /2. Remarque : En r\u00e9alit\u00e9 la pr\u00e9cision machine est au maximum \u00e9gale \u00e0 \u03b5 m ou \u03b5 mais dans la pratique on confond la pr\u00e9cision avec cette borne. La convention IEEE-754 Norme visant \u00e0 standardiser la repr\u00e9sentation des nombres sur les ordinateurs. En particulier elle impose le nombre de bits pour la mantisse, et l\u2019exposant pour les nombres reels \u00e0 32 bits (simple precision) et les reels 64 bits (double precision). Fait en sorte que l\u2019on peut determiner la precision machine ainsi que le plus grand et plus petit reels (simple et double precision) repr\u00e9sentable ind\u00e9pendemment de l\u2019ordinateur . simple precision double precision \u03b5 m 0.119 \u00d7 10\u22126 0.222 \u00d7 10\u221215 plus petit r\u00e9el (normalis\u00e9e) 1.2 \u00d7 10\u221238 2.2 \u00d7 10\u2212308 plus petit r\u00e9el (non-normalis\u00e9e) 1.4 \u00d7 10\u221245 4.9 \u00d7 10\u2212324 plus grand r\u00e9el 3.4 \u00d7 1038 1.8 \u00d7 10308 Maths-Info (ENSAM) CMN 30 septembre 2011 30 / 42 Repr\u00e9sentation des nombres sur ordinateur IEEE-754 D\u00e9calage de l\u2019exposant L\u2019exposant \u00e9tant repr\u00e9sent\u00e9 par un nombre sign\u00e9 (compl\u00e9ment \u00e0 2), la comparaison entre les nombres flottants devient un peu plus difficile. Pour remedier \u00e0 ce probl\u00e8me, l\u2019exposant est d\u00e9cal\u00e9, afin de le stocker sous forme d\u2019un nombre non sign\u00e9. Ce d\u00e9calage est de 2 e \u22121 \u2212 1 ( e repr\u00e9sente le nombre de bits de l\u2019exposant); il s\u2019agit donc d\u2019une valeur constante une fois que le nombre de bits e est fix\u00e9 : valeur = signe \u00d7 1, mantisse \u00d7 2( exposant \u2212 decalage ) Format simple pr\u00e9cision (32 bits) Un nombre flottant simple pr\u00e9cision est stock\u00e9 dans un mot de 32 bit : 1 bit de signe, 8 bits pour l\u2019exposant et 23 pour la mantisse. L\u2019exposant est donc d\u00e9cal\u00e9 de 28\u22121 \u2212 1 = 127 dans ce cas. L\u2019exposant -127 (qui est d\u00e9cal\u00e9 vers la valeur 0) est r\u00e9serv\u00e9 pour z\u00e9ro et les nombres d\u00e9normalis\u00e9s, tandis que l\u2019exposant 128 (d\u00e9cal\u00e9 vers 255) est r\u00e9serv\u00e9 pour coder les infinis et les NaNs. Exemple1 Pour 0 01111100 01000000000000000000000,l\u2019exposant est 124 \u2212 127 = \u22123 et la partie significative est 1,01 soit 1,25 en d\u00e9cimal (1 x 20 + 0 x 2\u22121 + 1 x 2\u22122); le nombre repr\u00e9sent\u00e9 est donc +1,25 x 2\u22123 soit +0, 15625. Exemple2 Codons le nombre -118,625 en utilisant IEEE 754. 1 C\u2019est un nombre n\u00e9gatif, le signe est donc \"1\". 1 Nous \u00e9crivons le nombre (sans le signe) en binaire. Nous obtenons 1110110,101. 1 Nous d\u00e9calons la virgule vers la gauche, de fa\u00e7on \u00e0 ne laisser qu\u2019un 1 sur sa gauche : 1110110,101 (bin) = 1,110110101 (bin) x C\u2019est un nombre flottant normalis\u00e9 : la mantisse est la partie \u00e0 droite de la virgule, remplie de 0 vers la droite pour obtenir 23 bits. Cela donne 110 1101 0100 0000 0000 0000 (on omet le 1 avant la virgule, qui est implicite). 1 L\u2019exposant est \u00e9gal \u00e0 6, et nous devons le convertir en binaire et le d\u00e9caler. Pour le format 32-bit IEEE 754, le d\u00e9calage est 28\u22121 \u2212 1 = 127. Donc 6 + 127 = 133 (dec) = 1000 0101 (bin). -118,625 (dec) = 1100 0010 1110 1101 0100 0000 0000 0000 (bin) C2ED4000 (hexa) Format double pr\u00e9cision (64 bits) Le format double pr\u00e9cision est identique au simple pr\u00e9cision, mis \u00e0 part le fait que les champs sont plus grands. En effet, il poss\u00e8de 52 bits de mantisse, et 11 bits d\u2019exposant. La mantisse est tr\u00e8s \u00e9largie, alors que l\u2019exposant est peu \u00e9largi. Ceci est d\u00fb au fait que, selon les cr\u00e9ateurs du standard, la pr\u00e9cision est plus importante que l\u2019amplitude. Les NaNs et les infinis sont repr\u00e9sent\u00e9s en mettant tous les bits de l\u2019exposant \u00e0 1 (2047). Pour les nombres normalis\u00e9s, le d\u00e9calage de l\u2019exposant est +1023. Maths-Info (ENSAM) CMN 35 septembre 2011 35 / 42 Arithm\u00e9tique flottante Mod\u00e8le de l\u2019arithm\u00e9tique flottante Les op\u00e9rations \u00e9l\u00e9mentaires sont effectu\u00e9es en arithm\u00e9tique flottante x + y \u2212\u2192 fl ( fl ( x ) + fl ( y ) ) x \u2212 y \u2212\u2192 fl ( fl ( x ) \u2212 fl ( y ) ) de la mani\u00e8re suivante : Attention : x \u00f7 y \u2212\u2192 fl ( fl ( x ) \u00f7 fl ( y ) ) x \u00d7 y \u2212\u2192 fl ( fl ( x ) \u00d7 fl ( y ) ) plusieurs propri\u00e9t\u00e9s de l\u2019arithm\u00e9tique : associativit\u00e9, distributivit\u00e9, etc ne sont plus valides (pas toujours) en arithm\u00e9tique flottante! Maths-Info (ENSAM) CMN 36 septembre 2011 36 / 42 Arithm\u00e9tique flottante Associativit\u00e9 Par exemple : supposons que les r\u00e9els soient calcul\u00e9s avec n = 3 chiffres significatifs et arrondis \u00e0 la d\u00e9cimale la plus proche. Soient x = 8,22, y = 0,00317, z = 0,00432 ( x + y ) + z = x + ( y + z ) Arithm\u00e9tique flottante Distributivit\u00e9 Encore avec n =3 x \u00d7 ( y + z ) = x \u00d7 y + x \u00d7 z 122 \u00d7 (333 + 695) = fl ( 0,122 103 \u00d7 fl ( 0,333 103 + 0,695 103 )) fl ( 0,122 103 \u00d7 fl ( 1,028 103 )) fl ( 0,122 103 \u00d7 fl ( 0,103 104 )) fl ( 0,012566 107 )) 0,126 106 (122 \u00d7 333)+ (122 \u00d7 695) = fl ( fl ( 0,122 103 \u00d7 0,333 103 ) + fl ( 0,122 103 \u00d7 0,695 103 )) fl ( fl ( 0,040626 106 + fl ( 0,08479 106 ) fl ( 0,406 105 + 0,848 105 ) fl ( 1,254 105 ) 0,125 106 Il ya donc une diff\u00e9rence entre les deux r\u00e9sultats. Arithm\u00e9tique flottante Attention \u00e0 l\u2019exposant!!! Il faut \u00eatre prudent avec l\u2019addition et la soustraction. Lorsque les exposants ne sont pas les m\u00eames il est n\u00e9cessaire de d\u00e9caler la mantisse avant d\u2019effectuer l\u2019addition ou la soustraction. Pour n = 4 0,4035 106 + 0,1978 104 = fl ( 0,4035 106 + 0,1978 104 ) fl ( 0,4035 106 + 0,001978 106 ) fl ( 0,405478 106 ) 0,4055 106 et 0,56789 104 \u2212 0,1234321 106 = fl ( 0,5679 104 \u2212 0,1234 106 ) fl ( 0,005679 106 \u2212 0,1234 106 ) fl ( \u22120,11772 106 ) \u22120,1177 106 Arithm\u00e9tique flottante Ph\u00e9nom\u00e8ne de cancellation Il existe d\u2019autre part, un certain nombre d\u2019op\u00e9rations risqu\u00e9es. Soustraire deux nombres presque identiques : \u221a 7001 \u2212 7000 = 0,8367 102 \u2212 0,8367 102 0,000 100 si n = 4 \u221a 7001 \u2212 7000 = 0,83672 102 \u2212 0,83666 102 0,6 10\u22122 si n = 5 Dans ce cas-ci on peut rem\u00e9dier \u00e0 cette difficult\u00e9 en \u00e9vitant la soustraction des racines : \u221a x \u2212 y x \u2212 y = \u221a \u221a x + y et on trouve 0,5977 10\u22122 au lieu de 0 pour n = 4. Arithm\u00e9tique flottante Conclusion L\u2019ordre dans lequel on fait les op\u00e9rations et le nombre d\u2019op\u00e9rations ont un impact important sur la pr\u00e9cision du r\u00e9sultats. Ainsi on devrait \u201dtoujours\u201c : \u00e9viter les op\u00e9rations avec des nombres tr\u00e8s diff\u00e9rents en ordre de grandeurs, \u00e9viter si possibles les soustractions avec des nombre relativement proche, on devrait faire les sommes en ordre d\u00e9croissant. Maths-Info (ENSAM) CMN 42 septembre 2011 42 / 42","title":"heartbeat4palestine"}]}